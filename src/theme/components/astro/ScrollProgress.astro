---
interface Props {
	selector: string
	size?: number
	strokeWidth?: number
	class?: string
}

const { selector, size = 60, strokeWidth = 4, class: className } = Astro.props

const radius = (size - strokeWidth) / 2
const circumference = 2 * Math.PI * radius
---

<script>
	import { defineCustomElement } from '../../utils/define-custom-element'

	class ScrollProgress extends HTMLElement {
		private targetElement: Element | null = null
		private progressCircle: SVGCircleElement | null = null
		private percentageText: HTMLDivElement | null = null
		private circumference: number = 0
		private observer: ResizeObserver | null = null

		connectedCallback() {
			const selector = this.dataset.selector
			if (!selector) {
				console.error('ScrollProgress: selector is required')
				return
			}

			this.circumference = Number(this.dataset.circumference) || 0
			this.progressCircle = this.querySelector('.progress-circle')
			this.percentageText = this.querySelector('.percentage')

			// Find target element
			this.targetElement = document.querySelector(selector)
			if (!this.targetElement) {
				console.error(
					`ScrollProgress: element not found for selector "${selector}"`,
				)
				return
			}

			// Listen to scroll events
			this.targetElement.addEventListener('scroll', this.handleScroll)

			// Listen to resize events to recalculate on content changes
			this.observer = new ResizeObserver(() => {
				this.handleScroll()
			})
			this.observer.observe(this.targetElement)

			// Initial update
			this.handleScroll()
		}

		disconnectedCallback() {
			if (this.targetElement) {
				this.targetElement.removeEventListener('scroll', this.handleScroll)
			}
			if (this.observer) {
				this.observer.disconnect()
			}
		}

		private handleScroll = () => {
			if (!this.targetElement || !this.progressCircle || !this.percentageText) {
				return
			}

			const { scrollTop, scrollHeight, clientHeight } = this.targetElement
			const maxScroll = scrollHeight - clientHeight

			// Calculate percentage
			const percentage = maxScroll > 0 ? (scrollTop / maxScroll) * 100 : 0
			const clampedPercentage = Math.min(100, Math.max(0, percentage))

			// Update circle progress
			const offset =
				this.circumference - (clampedPercentage / 100) * this.circumference
			this.progressCircle.style.strokeDashoffset = String(offset)

			// Update percentage text
			this.percentageText.textContent = `${Math.round(clampedPercentage)}%`
		}
	}

	defineCustomElement('scroll-progress', ScrollProgress)
</script>

<scroll-progress
	data-selector={selector}
	data-size={size}
	data-stroke-width={strokeWidth}
	data-radius={radius}
	data-circumference={circumference}
	class:list={['relative inline-block', className]}
>
	<svg width={size} height={size} class="rotate-[-90deg]">
		<!-- Background circle -->
		<circle
			cx={size / 2}
			cy={size / 2}
			r={radius}
			fill="none"
			stroke="currentColor"
			stroke-width={strokeWidth}
			opacity="0.2"></circle>
		<!-- Progress circle -->
		<circle
			class="progress-circle"
			cx={size / 2}
			cy={size / 2}
			r={radius}
			fill="none"
			stroke="currentColor"
			stroke-width={strokeWidth}
			stroke-dasharray={circumference}
			stroke-dashoffset={circumference}
			stroke-linecap="round"></circle>
	</svg>
	<div class="percentage absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-xs font-semibold select-none">0%</div>
</scroll-progress>
